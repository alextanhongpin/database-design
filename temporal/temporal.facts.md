# Temporal Facts

Temporal databases includes mainly two time dimensions namely valid time and transaction
time. Valid time and transaction time can be merged to create bitemporal data.

- Valid time is the time period during which a fact is true with respect to the real world.
- Transaction time is the time period during which a fact stored in the database is considered
to be true.
- Bitemporal data combines both Valid and Transaction Time

Reference [here](https://www.researchgate.net/publication/282835771_Checking_and_Verifying_Temporal_Data_Validity_Using_Valid_Time_Temporal_Dimension_and_Queries_in_Oracle_12C/fulltext/5680cdc108ae1975838b838a/Checking-and-Verifying-Temporal-Data-Validity-Using-Valid-Time-Temporal-Dimension-and-Queries-in-Oracle-12C.pdf).

For the example below, `system_period` refers to the transaction time, and `active_period` refers to the `valid time`.


Ideally, the system time is generated by default, e.g. `not null default now()`. The example below overrides the created at for illustration purpose.


Compared to history table which is immutable, the bitemporal table is mutable, because sometimes we want to deal with data correction in the past, e.g. updating an individual's address, which could be corrected later in future date. However, we do not want to delete all past data as they may be useful (or they might affect reporting in some ways, and the change is not captured which cause confusion).


The example below does not follow the original implementation of bitemporal... Instead, we take an easier shortcut.
- for any correction made, we just invalidate all the past data and set the deleted_at to the current time
- then, we recreate the new data with the corrected effective at time

```sql
create table if not exists users (
	id int generated always as identity,
	name text not null,

	primary key(id),
	unique(name)
);
insert into users (name) values ('john');

drop table if exists user_addresses;
create table if not exists user_addresses (
	id int generated always as identity,
	address text not null,
	user_id int not null,
	effective_at timestamptz not null default now(),
	created_at timestamptz not null default now(),
	deleted_at timestamptz,

	primary key(id),
	foreign key(user_id) references users(id)
);

-- One user can only have one effective address at a time.
CREATE UNIQUE INDEX unique_active_address_per_user ON user_addresses (user_id, effective_at) WHERE (deleted_at is NOT null);

-- The Customs recorded the following on the 12th
-- John is in Malaysia on the 1st Jan
-- John is in Singapore on the 10th Jan

-- The Customs recorded the following on the 16th
-- John is back in Malaysia until future on the 15th Jan
insert into user_addresses(user_id, address, effective_at, created_at) values
(1, 'Malaysia', '2022-01-01', '2022-01-12'),
(1, 'Singapore', '2022-01-10', '2022-01-12'),
(1, 'Malaysia', '2022-01-15', '2022-01-16');

-- On the 25th Jan, John reported that he was in Singapore on the 8th Jan instead of 10th Jan.
update user_addresses set deleted_at = '2022-01-25';
insert into user_addresses(user_id, address, effective_at, created_at) values
(1, 'Malaysia', '2022-01-01', '2022-01-25'),
(1, 'Singapore', '2022-01-08', '2022-01-25'),
(1, 'Malaysia', '2022-01-15', '2022-01-25');

select * from user_addresses;

create or replace view user_address_bitemporal as (
	select
		id,
		user_id,
		address,
		-- System period is the current time when the changes are made.
		tstzrange (
			created_at,
			deleted_at,
			'[)'
		) as system_period,
		tstzrange(
			effective_at, -- start date
			lead(effective_at, 1) over (partition by user_id, deleted_at order by effective_at asc), -- end_date
			'[)'
		) as active_period,
		-- Everytime we make a correction, we delete all old entries and they can be considered a separate timeline, hence they can be grouped under a version.
		dense_rank() over (partition by user_id order by deleted_at nulls last) as version,
		created_at
	from user_addresses
	order by deleted_at nulls last, effective_at asc
);

select *
from user_address_bitemporal;

-- Find where john is on the 7th Jan.
-- We will get two rows, the first row shows he's in Malaysia from the 1st Jan to the 10th, but is later corrected on the 25th Jan.
-- The second row shows that he's in Singapore, and the correction is made on the 25th
select *
from user_address_bitemporal
where active_period @> '2022-01-08'::timestamptz;

-- To illustrate how this is useful, let's say we are generating a report to find who lives in Singapore on the 15th on Jan.
-- We would have one less record since the first record says that John is still in Malaysia that time.
select *
from user_address_bitemporal
where active_period @> '2022-01-08'::timestamptz and system_period @> '2022-01-15'::timestamptz;

-- Had the report been made on the 26th, then John would have been reported to be in Singapore (one additional count)
select *
from user_address_bitemporal
where active_period @> '2022-01-08'::timestamptz and system_period @> '2022-01-26'::timestamptz;

-- Find only valid version, and valid effective at.
select *
from user_address_bitemporal
where system_period @> now()
and active_period @> now();
```

References
- https://www.marklogic.com/blog/bitemporal/
